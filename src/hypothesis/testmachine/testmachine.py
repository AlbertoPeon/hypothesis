# coding=utf-8

# Copyright (C) 2013-2015 David R. MacIver (david@drmaciver.com)

# This file is part of Hypothesis (https://github.com/DRMacIver/hypothesis)

# This Source Code Form is subject to the terms of the Mozilla Public License,
# v. 2.0. If a copy of the MPL was not distributed with this file, You can
# obtain one at http://mozilla.org/MPL/2.0/.

# END HEADER

from __future__ import division, print_function, unicode_literals

import traceback

from hypothesis.internal.compat import hrange

from .context import RunContext, TestMachineError
from .operations import ChooseFrom


class NoFailingProgram(TestMachineError):
    pass


class TestMachine(object):

    def __init__(
        self,
        n_iters=500,
        prog_length=200,
        good_enough=10,
        print_output=True,
        simulation=False,
        verbose=False,
    ):
        self.verbose = verbose
        self.languages = []
        self.n_iters = n_iters
        self.prog_length = prog_length
        self.good_enough = good_enough
        self.print_output = print_output
        self.simulation = simulation

    def inform(self, message):
        if self.print_output:
            print(message)

    def maybe_print_exc(self):
        if self.verbose:
            traceback.print_exc()

    def __repr__(self):
        return 'TestMachine()'

    def print_execution_log(self, context):
        for step in context.log:
            statements = step.operation.compile(
                arguments=step.arguments, results=step.definitions
            )
            for statement in statements:
                self.inform(statement)

    def trial_run(self):
        context = RunContext(simulation=self.simulation)
        try:
            for _ in hrange(self.prog_length):
                operation = self.language.generate_from(context)
                context.execute(operation)
        finally:
            self.print_execution_log(context)

    def print_program_results(self, program):
        context = RunContext(simulation=True)
        try:
            context.run_program(program)
        except Exception:
            self.maybe_print_exc()
        self.print_execution_log(context)
        try:
            RunContext().run_program(program)
            assert False, "This program should be failing but isn't"
        except Exception:
            traceback.print_exc()

    def run(self):
        """run this testmachine and return a minimal failing program, or None
        if no such program can be found.

        If self.print_output is True then this will print a nice
        representation of the group to stdout and the exception
        generated by the failure.

        """
        try:
            first_try = self.find_failing_program()
        except NoFailingProgram as e:
            self.inform(str(e))
            return

        minimal = self.minimize_failing_program(first_try)

        if self.print_output:
            self.print_program_results(minimal)

        return minimal

    def add(self, *languages):
        self.languages.extend(languages)

    @property
    def language(self):
        return ChooseFrom(self.languages)

    def generate_program(self):
        context = RunContext(simulation=True)
        results = []
        for _ in hrange(self.prog_length):
            operation = self.language.generate_from(context)
            context.execute(operation)
            results.append(operation)
        return results

    def program_fails(self, program):
        try:
            self.run_program(program)
            return False
        except Exception:
            return True

    def find_failing_initial_segment(self, program):
        low = 0
        high = len(program)

        # invariant: program[:high] fails, program[:low] doesn't
        while high - low > 1:
            mid = (low + high) // 2
            x = program[:mid]
            if self.program_fails(x):
                high = mid
            else:
                low = mid
        return program[:high]

    def find_failing_program(
        self,
    ):
        examples_found = 0
        best_example = None

        for _ in range(self.n_iters):
            program = self.generate_program()
            if self.program_fails(program):
                program = self.find_failing_initial_segment(program)
                examples_found += 1
                if (
                    (best_example is None) or
                    (len(program) < len(best_example))
                ):
                    best_example = program
                if examples_found >= self.good_enough:
                    return best_example

        if best_example is None:
            raise NoFailingProgram(
                ('Unable to find a failing program of length <= %d'
                 ' after %d iterations') % (self.prog_length, self.n_iters)
            )
        return best_example

    def run_program(self, program):
        context = RunContext()
        context.run_program(program)
        return context

    def prune_program(self, program):
        context = RunContext(simulation=True)
        results = []
        for operation in program:
            if not operation.applicable(context.heights()):
                continue
            results.append(operation)
            try:
                context.execute(operation)
            except Exception:
                break

        return results

    def shrink(self, program):
        for i in hrange(len(program)):
            copy = list(program)
            del copy[i]
            yield self.prune_program(copy)
            if i < len(copy):
                del copy[i]
                yield self.prune_program(copy)

    def minimize_failing_program(self, program):
        assert self.program_fails(program)
        current_best = program
        while True:
            for child in self.shrink(current_best):
                if self.program_fails(child):
                    current_best = child
                    break
            else:
                return current_best
